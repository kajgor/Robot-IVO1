import datetime
import socket
import cairo
import math
import time
import re

import gi
gi.require_version('Gst', '1.0')
gi.require_version('Gdk', '3.0')
gi.require_version('GstVideo', '1.0')
from gi.repository import Gst, GstVideo, Gdk
# from os import system
import subprocess
# from subprocess import call
from _thread import *
from init_variables import *

Gst.init(None)
# Gdk.threads_init()


class MainLoop:
    ###############################################################################
    ################   MAIN LOOP START   ##########################################
    ###############################################################################
    def __init__(self, GUI):
        self.GUI = GUI
        self.counter = 0

    def on_timer(self):
        if COMM_vars.connected:
            self.counter += .05

        if COMM_vars.comm_link_idle > COMM_IDLE:
            self.GUI.spinner_connection.stop()
            COMM_vars.comm_link_idle = COMM_IDLE  # Do not need to increase counter anymore
        else:
            self.GUI.spinner_connection.start()

        # Idle timer for checking the link
        COMM_vars.comm_link_idle += 1

        # Any update tasks would go here (moving sprites, advancing animation frames etc.)
        self.UpdateControlData()
        self.UpdateMonitorData()

        self.GUI.statusbar2.push(self.GUI.context_id2, str(datetime.timedelta(seconds=int(self.counter))))
        self.GUI.drawingarea_control.queue_draw()

        if COMM_vars.connected is True:
            if CommunicationFFb is False:
                RacUio.get_speed_and_direction()  # Keyboard input
                RacUio.calculate_MotorPower()
                RacUio.mouseInput()               # Mouse input

        else:
            self.GUI.button_connect.set_active(False)
            self.GUI.on_ToggleButton_Connect_toggled(self.GUI.button_connect)

        return True

    def UpdateMonitorData(self):
        self.GUI.LabelRpmL.set_text(COMM_vars.Motor_RPM[LEFT].__str__())
        self.GUI.LabelRpmR.set_text(COMM_vars.Motor_RPM[RIGHT].__str__())
        self.GUI.LabelPowerL.set_text(COMM_vars.Motor_PWR[LEFT].__str__())
        self.GUI.LabelPowerR.set_text(COMM_vars.Motor_PWR[RIGHT].__str__())
        self.GUI.LabelRpmReqL.set_text(COMM_vars.Motor_Power[LEFT].__str__())
        self.GUI.LabelRpmReqR.set_text(COMM_vars.Motor_Power[RIGHT].__str__())
        self.GUI.LabelRpmAckL.set_text(COMM_vars.Motor_ACK[LEFT].__str__())
        self.GUI.LabelRpmAckR.set_text(COMM_vars.Motor_ACK[RIGHT].__str__())
        self.GUI.LabelCamPosH.set_text(COMM_vars.CamPos[X_AXIS].__str__())
        self.GUI.LabelCamPosV.set_text(COMM_vars.CamPos[Y_AXIS].__str__())

        self.GUI.LabelCoreTemp.set_text("{:.2f}".format(COMM_vars.CoreTemp).__str__())
        self.GUI.LabelBattV.set_text("{:.2f}".format(COMM_vars.Voltage).__str__())
        self.GUI.LabelPowerA.set_text("{:.2f}".format(COMM_vars.Current).__str__())
        self.GUI.LabelS1Dist.set_text(COMM_vars.DistanceS1.__str__())

        return

    def UpdateControlData(self):
        self.GUI.LevelBar_Voltage.set_value(int(COMM_vars.Voltage * 10))
        self.GUI.LevelBar_Current.set_value(int(COMM_vars.Current * 10))
        self.GUI.LeverBar_PowerL.set_value(65)
        self.GUI.LeverBar_PowerR.set_value(65)
        # print("int(COMM_vars.Current * 10) - 70", int(COMM_vars.Current * 10))

        return
###############################################################################
################   MAIN LOOP END   ############################################
###############################################################################


# noinspection PyPep8Naming
class RacConnection:
    srv = None
    Test_Mode = False
    Host = None
    Port_Comm = None
    Last_Active = 0
    player = [Gst.Pipeline.new("player"),
              Gst.Pipeline.new("player_test")]

    def __init__(self):
        self.source = [Gst.ElementFactory.make("tcpclientsrc", "source"),
                       Gst.ElementFactory.make("tcpclientsrc", "source_test")]
        self.decoder = [Gst.ElementFactory.make("gdpdepay", "decoder"),
                        Gst.ElementFactory.make("gdpdepay", "decoder_test")]
        self.vconvert = [Gst.ElementFactory.make("videoconvert"),
                         Gst.ElementFactory.make("videoconvert")]
        self.sink = [Gst.ElementFactory.make("ximagesink", "sink"), # glimagesink(default)/gtksink/cacasink/autovideosink
                     Gst.ElementFactory.make("ximagesink", "sink_test")]
        self.sink[False].set_property("sync", False)
        self.sink[True].set_property("sync", False)
        self.Cam_idle = 0

        if not self.sink or not self.source:
            print("GL elements not available.")
            exit()

        # if self.Test_Mode is True:
        self.gst_init_test()
        # else:
        self.gst_init_cam()

    def gst_init_test(self):
        # receive raw test image generated by gstreamer server
        # --- Gstreamer setup begin ---
        self.player[True].add(self.source[True])
        self.player[True].add(self.decoder[True])
        self.player[True].add(self.vconvert[True])
        self.player[True].add(self.sink[True])

        self.source[True].link(self.decoder[True])
        self.decoder[True].link(self.vconvert[True])
        self.vconvert[True].link(self.sink[True])
        # --- Gstreamer setup end ---

    def gst_init_cam(self):
        # --- Gstreamer setup begin ---
        rtimer = Gst.ElementFactory.make("rtph264depay", "rtimer")
        avdec = Gst.ElementFactory.make("avdec_h264", "avdec")
        # Flip video horizontally
        video_flip = Gst.ElementFactory.make("videoflip", "flip")
        video_flip.set_property("method", "rotate-180")

        self.player[False].add(self.source[False])
        self.player[False].add(self.decoder[False])
        self.player[False].add(rtimer)
        self.player[False].add(avdec)
        self.player[False].add(self.vconvert[False])
        self.player[False].add(video_flip)
        self.player[False].add(self.sink[False])

        self.source[False].link(self.decoder[False])
        self.decoder[False].link(rtimer)
        rtimer.link(avdec)
        avdec.link(self.vconvert[False])
        self.vconvert[False].link(video_flip)
        video_flip.link(self.sink[False])
        # --- Gstreamer setup end ---

    def establish_connection(self):
        if Debug > 2: print("Estabilishing Connection:", self.Host, self.Port_Comm)

        # Gstreamer setup start
        self.source[self.Test_Mode].set_property("host", self.Host)
        self.source[self.Test_Mode].set_property("port", self.Port_Comm.__int__() + 1)
        # Gstreamer setup end

        start_new_thread(self.connection_thread, (self.Host, self.Port_Comm))
        time.sleep(1.5)

        return COMM_vars.connected

    def close_connection(self):
        if Debug > 1:
            print("Closing connection...")
        self.player[self.Test_Mode].set_state(Gst.State.NULL)

        try:
            self.srv.shutdown(socket.SHUT_RDWR)
        except OSError:
            if Debug > 1:
                print("...not connected!")
        except AttributeError:
            if Debug > 1:
                print("...not connected!")

        try:
            RacConnection.srv.close()
        except AttributeError:
            RacConnection.srv = None

        COMM_vars.connected = False
        if Debug > 1: print("Connection closed.")

    @staticmethod
    def check_connection(HostIp):
        try:
            # status = self.srv.getsockname()
            status = RacConnection.srv.getpeername()
            # print("Status", status)
        except OSError:
            status = (False, False)

        if not HostIp:
            if status[0] != '0.0.0.0':
                HostIp = status[0]

        if status[0] == HostIp:
            if Debug > 2: print("Connection status: " + status.__str__())
            return True
        else:
            if Debug > 1: print("Not connected.")
            return False

    ###############################################################################
    ################   COMMUNICATION LOOP START   #################################
    ###############################################################################

    def connection_thread(self, Host, Port_Comm):
        if Debug > 2: print("Connecting...")
        RacConnection.srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_address = (Host, Port_Comm)
        IP_addr = socket.gethostbyname(Host)
        print(server_address, "[", IP_addr, "]")
        try:
            self.srv.connect(server_address)
            COMM_vars.connected = True
            if Debug > 2: print("Connected! self.srv.getpeername()", self.srv.getpeername())
        except ConnectionResetError:
            COMM_vars.connected = False
            if Debug > 0: print("Server not responding <", COMM_vars.connected, ">")
        except ConnectionRefusedError:
            COMM_vars.connected = False
            if Debug > 0: print("Server refused connection <", COMM_vars.connected, ">")
        except socket.gaierror:
            COMM_vars.connected = False
            if Debug > 0: print("Invalid protocol <", COMM_vars.connected, ">")

        if COMM_vars.connected is True:
            time.sleep(1.48)
            # Send initial string for Gstreamer
            ipint_list = map(int, re.findall('\d+', IP_addr))
            initstr = "IP" + chr(self.Test_Mode + COMM_BITSHIFT)
            for ipint in ipint_list:
                initstr += chr(ipint + COMM_BITSHIFT)
            print(">>>>> initstr:", initstr)
            self.transmit_message(initstr)

        # rac__uio = RacUio()
        restart = bool(COMM_vars.resolution)
        resolution_last = COMM_vars.resolution
        while COMM_vars.connected is True:
            if CommunicationFFb is True:
                RacUio.get_speed_and_direction()  # Keyboard input
                RacUio.calculate_MotorPower()     # Set control variables
                RacUio.mouseInput()               # Set mouse Variables
# ToDo: resolution_last to be local
            if COMM_vars.resolution != resolution_last:
                restart = bool(COMM_vars.resolution)
                print("COMM_vars.camera", restart)
                resolution_last = COMM_vars.resolution
                print("stopping cam video!")
                self.connect_camstream(False)

            # print("res_changed", res_changed)
            if COMM_vars.resolution == COMM_vars.streaming_mode and restart is True:
                restart = False
                print("starting cam video!")
                restart = self.connect_camstream(True)

            if self.check_connection(None) is True:
                self.send_and_receive()

        self.close_connection()
        print("Closing Thread: COMM_vars.connected is", COMM_vars.connected)
        exit_thread()

    def send_and_receive(self):
        if COMM_vars.speed != "HALT":
            request  = self.encode_message()
            checksum = self.transmit_message(request)
            if checksum is None:
                COMM_vars.ConnErr += 1
                if COMM_vars.ConnErr > COMM_vars.RetryCnt:
                    COMM_vars.ConnErr = 0
                    COMM_vars.connected = False
                return
            else:
                COMM_vars.ConnErr = 0

            time.sleep(COMM_vars.RESP_DELAY)
            resp = self.receive_message()
            if resp is not None:
                if checksum == ord(resp[0]):
                    RacConnection.decode_transmission(resp)
                    COMM_vars.Motor_ACK = COMM_vars.Motor_Power
                if Debug > 1:
                    print("CheckSum Sent/Received:", checksum, ord(resp[0]))
        else:
            self.transmit_message("HALTHALT")
            COMM_vars.connected = False

    ###############################################################################
    ################   CONN LOOP END   ############################################
    ###############################################################################

    def connect_camstream(self, connect):
        if connect is True:
            time.sleep(0.1)
            retmsg = self.player[self.Test_Mode].set_state(Gst.State.PLAYING)
        else:
            retmsg = self.player[self.Test_Mode].set_state(Gst.State.NULL)

        if retmsg == Gst.StateChangeReturn.FAILURE:
            return True
        else:
            return False

    def conect_micstream(self):
        retmsg = self.player[self.Test_Mode].set_state(Gst.State.PLAYING)
        if retmsg == Gst.StateChangeReturn.FAILURE:
            retmsg = "VIDEO CONNECTION ERROR: Unable to set the pipeline to the playing state."
            success = False
        else:
            retmsg = "VIDEO CONNECTION ESTABILISHED: OK"
            success = True

        if Debug > 1: print(retmsg)
        return retmsg, success

    def transmit_message(self, out_str):
        sendstr = str(chr(COMM_BITSHIFT - 1) + out_str + chr(10)).encode(Encoding)
        if Debug > 1:
            print("CLISENT[len]: " + len(sendstr).__str__())

        if self.srv is None:
            print("self.srv is NONE!")
            return None
        try:
            self.srv.sendall(sendstr)
        except BrokenPipeError:
            print("transmit_message: BrokenPipeError")
            return None
        except AttributeError:
            print("transmit_message: AttributeError")
            return None
        except OSError:
            print("transmit_message: OSError (server lost)")
            return None

        return calc_checksum(sendstr)

    def receive_message(self):
        try:
            data = self.srv.recv(RECMSGLEN).decode(Encoding)
        except ConnectionResetError:
            return None
        except OSError:
            return None

        if Debug > 2:
            print("CLIRCVD[len]: " + len(data).__str__())

        try:
            data_end = data[14]
        except IndexError:
            data_end = False

        if data_end == chr(10):
            COMM_vars.comm_link_idle = 0
            return data
        else:
            try:
                self.srv.recv(1024)  # flush buffer
            except OSError:
                print("transmit_message [flush]: OSError (server lost)")
                return None

            if Debug > 1: print(">>>FlushBuffer>>>")
            return None

    @staticmethod
    def update_server_list(combobox_host, port):
        list_iter = combobox_host.get_active_iter()
        if list_iter is not None:
            model = combobox_host.get_model()
            Host, Port = model[list_iter][:2]
            try:
                Port = Port[:Port.index('.')]
            except:
                Port = Port

            # print("Selected: Port=%s, Host=%s" % (int(Port), Host))
        else:
            entry = combobox_host.get_child()
            combobox_host.prepend(port.__str__(), entry.get_text())
            combobox_host.set_active(0)

            print("New entry: %s" % entry.get_text())
            print("New port: %s" % port.__str__())

    def HostList_get(self, model, HostToFind):
        HostList = []
        for iter_x in range(0, model.iter_n_children()):
            if HostToFind is None:
                HostList.append(model[iter_x][0] + ":" + model[iter_x][1])
            else:
                if model[iter_x][0] == HostToFind:
                    return iter_x

        if HostToFind is None:
            print("HostList_str: [%d]" % model.iter_n_children(), HostList)
            return HostList
        else:
            return False

    def config_snapshot(self, Host):
        self.Host = Host
        # ToDo:
        self.Port_Comm = "5000"
        self.Port_Video = "5001"
        self.Port_Audio = "5002"
        self.Gstreamer_Path = "/usr/bin"

    def load_HostList(self, combobox_host, HostList_str):
        x = 0
        for HostName in HostList_str:
            Host = HostName.split(":")[0]
            Port = HostName.split(":")[1]
            combobox_host.insert(x, Port, Host)
            x += 1

    @staticmethod
    def decode_transmission(resp):
        # checksum  - transmission checksum
        # Motor_PWR - power delivered to motors
        # Motor_RPM - Motor rotations
        # CheckSum = ord(resp[0])

        COMM_vars.Motor_PWR[RIGHT] = (ord(resp[1]) - COMM_BITSHIFT) + (ord(resp[2]) - COMM_BITSHIFT)
        COMM_vars.Motor_PWR[LEFT] = (10 * ((ord(resp[1]) - COMM_BITSHIFT) % 10)) + (ord(resp[3]) - COMM_BITSHIFT)

        COMM_vars.Motor_RPM[RIGHT] = (ord(resp[4]) - COMM_BITSHIFT) + (ord(resp[5]) - COMM_BITSHIFT)
        COMM_vars.Motor_RPM[LEFT] = (10 * ((ord(resp[4]) - COMM_BITSHIFT) % 10)) + (ord(resp[6]) - COMM_BITSHIFT)

        CntrlMask1 = ord(resp[6])
        CntrlMask2 = ord(resp[7])
        if CntrlMask1 >= COMM_BITSHIFT:
            COMM_vars.streaming_mode = CntrlMask1 - COMM_BITSHIFT

        COMM_vars.CoreTemp = float(ord(resp[9]) - COMM_BITSHIFT) * 0.5
        COMM_vars.Current  = float((ord(resp[10]) - COMM_BITSHIFT) * 10 + (ord(resp[11]) - COMM_BITSHIFT)) * 0.01
        COMM_vars.Voltage  = float((ord(resp[12]) - COMM_BITSHIFT) * 10 + (ord(resp[13]) - COMM_BITSHIFT)) * 0.01
        # print("Motor_ACK/PWR/RPM", COMM_vars.CheckSum, COMM_vars.Motor_PWR, COMM_vars.Motor_RPM)

    @staticmethod
    def encode_message():
        # print("MP l/r:", Motor_Power[RIGHT], Motor_Power[LEFT])
        # print("COMM_vars.Motor_Power", COMM_vars.Motor_Power)
        CntrlMask1 = 0
        for idx, x in enumerate([COMM_vars.light, COMM_vars.speakers, COMM_vars.mic,
                                 COMM_vars.display, COMM_vars.laser, 0, 0, 0]):
            CntrlMask1 |= (x << idx)

        requestMsg = chr(COMM_vars.Motor_Power[RIGHT] + 51 + COMM_BITSHIFT)
        requestMsg += chr(COMM_vars.Motor_Power[LEFT] + 51 + COMM_BITSHIFT)
        requestMsg += chr(COMM_vars.CamPos[X_AXIS])
        requestMsg += chr(COMM_vars.CamPos[Y_AXIS])
        requestMsg += chr(CntrlMask1)
        CntrlMask2 = COMM_vars.resolution
        requestMsg += chr(CntrlMask2 + COMM_BITSHIFT)
        if Debug == 2:
            print("requestMsg", requestMsg)

        return requestMsg


class RacDisplay:
    background_control = cairo.ImageSurface.create_from_png(Paths.background_file)

    def draw_arrow(self, message):
        message.set_source_surface(self.background_control, 15, 0)
        message.paint()

        message.set_line_width(1)
        message.translate(105, 81)

        if COMM_vars.speed >= 0:
            message.rotate(COMM_vars.direction / (math.pi * 5))
        else:
            message.rotate((COMM_vars.direction + MAX_SPEED) / (math.pi * 5))

        # Direction arrow
        message.set_source_rgb(0.25, 0.25, 0.25)
        for i in range(4):
            message.line_to(arrow.points[i][0], arrow.points[i][1])
        message.fill()
        message.set_source_rgb(0, 0.75, 0.75)
        for i in range(5):
            message.line_to(arrow.points[i][0], arrow.points[i][1])
        message.stroke()

        # Speed arrow (REQ)
        message.set_source_rgb(abs(COMM_vars.speed/MAX_SPEED), 1 - abs(COMM_vars.speed/MAX_SPEED), 0)
        message.line_to(arrow.points[0][0], arrow.points[0][1] + 60 - abs((COMM_vars.speed / MAX_SPEED) * 50))
        for i in range(1, 4):
                message.line_to(arrow.points[i][0], arrow.points[i][1])
        message.fill()

        # Speed arrow (ACK)
        message.set_source_rgb(0, 0.75, 0.75)
        speed_ACK = abs(COMM_vars.Motor_ACK[0] + COMM_vars.Motor_ACK[1]) * 0.5
        message.line_to(arrow.points[1][0], arrow.points[1][1])
        message.line_to(arrow.points[0][0], arrow.points[0][1] + 60 - speed_ACK)
        message.line_to(arrow.points[3][0], arrow.points[3][1])
        message.stroke()

    def on_message(self, message):
        msgtype = message.type
        if msgtype == Gst.MessageType.EOS:
            RacConnection.player[RacConnection.Test_Mode].set_state(Gst.State.NULL)
            if Debug > 1:
                # self.statusbar.push(self.context_id, "VIDEO CONNECTION EOS: SIGNAL LOST")
                print ("EOS: SIGNAL LOST")
            return "VIDEO CONNECTION EOS: SIGNAL LOST"
        elif msgtype == Gst.MessageType.ERROR:
            RacConnection.player[RacConnection.Test_Mode].set_state(Gst.State.NULL)
            err, debug = message.parse_error()
            debug_s = debug.split("\n")
            if Debug > 0:
                # self.statusbar.push(self.context_id, debug_s[debug_s.__len__() - 1])
                print ("ERROR:", debug_s)
            return debug_s[debug_s.__len__() - 1]
        else:
            return None

    def on_sync_message(self, message, SXID):
        if message.get_structure().get_name() == 'prepare-window-handle':
            imagesink = message.src
            imagesink.set_property("force-aspect-ratio", True)
            imagesink.set_window_handle(SXID.get_xid())


class RacUio:
    def on_key_press(self, event):
        keybuffer_set(event, True)
        return True

    def on_key_release(self, event):
        key_name = keybuffer_set(event, False)
        return key_name

    def on_mouse_press(self, mouse_event):
        mousebuffer_set(mouse_event, True)

    def on_mouse_release(self, mouse_event):
        mousebuffer_set(mouse_event, False)

    def on_motion_notify(self, mouse_event):
        mouseX = int(mouse_event.x) / 2
        mouseY = int(mouse_event.y) / 2
        if KEY_control.MouseBtn[LEFT] is True:
            tmp = mouseX - KEY_control.MouseXY[X_AXIS]
            if abs(tmp) >= 1:
                COMM_vars.CamPos[X_AXIS] += int(tmp)

            tmp = mouseY - KEY_control.MouseXY[Y_AXIS]
            if abs(tmp) >= 1:
                COMM_vars.CamPos[Y_AXIS] += int(tmp)

            KEY_control.MouseXY = [mouseX, mouseY]

        if KEY_control.MouseBtn[RIGHT] is True:
            print("KEY_control.MouseXY[right]", KEY_control.MouseXY)

    @staticmethod
    def get_speed_and_direction():
        # print("COMM_vars:", KEY_control.Down, KEY_control.Up, KEY_control.Left, KEY_control.Right, COMM_vars.speed, COMM_vars.direction)
        if KEY_control.Down is True:
            if COMM_vars.speed > -MAX_SPEED:
                COMM_vars.speed -= ACCELERATION

        if KEY_control.Up is True:
            if COMM_vars.speed < MAX_SPEED:
                COMM_vars.speed += ACCELERATION

        if KEY_control.Left is True:
            if COMM_vars.direction > -MAX_SPEED:
                COMM_vars.direction -= ACCELERATION
            else:
                COMM_vars.direction = MAX_SPEED - ACCELERATION

        if KEY_control.Right is True:
            if COMM_vars.direction < MAX_SPEED:
                COMM_vars.direction += ACCELERATION
            else:
                COMM_vars.direction = -MAX_SPEED + ACCELERATION

        return COMM_vars.speed, COMM_vars.direction

    @staticmethod
    def calculate_MotorPower():
        if COMM_vars.direction < MAX_SPEED/2 and COMM_vars.direction > -MAX_SPEED/2:
            direction = COMM_vars.direction
        else:
            offset = MAX_SPEED * (COMM_vars.direction / abs(COMM_vars.direction))
            direction = (-COMM_vars.direction + offset)

        COMM_vars.Motor_Power = [int(COMM_vars.speed - direction), int(COMM_vars.speed + direction)]
        return COMM_vars.Motor_Power

    @staticmethod
    def mouseInput():
        if COMM_vars.CamPos[X_AXIS] > MOUSE_MAX[X_AXIS]:
            COMM_vars.CamPos[X_AXIS] = MOUSE_MAX[X_AXIS]
        if COMM_vars.CamPos[X_AXIS] < MOUSE_MIN[X_AXIS]:
            COMM_vars.CamPos[X_AXIS] = MOUSE_MIN[X_AXIS]
        if COMM_vars.CamPos[Y_AXIS] > MOUSE_MAX[Y_AXIS]:
            COMM_vars.CamPos[Y_AXIS] = MOUSE_MAX[Y_AXIS]
        if COMM_vars.CamPos[Y_AXIS] < MOUSE_MIN[Y_AXIS]:
            COMM_vars.CamPos[Y_AXIS] = MOUSE_MIN[Y_AXIS]

        return COMM_vars.CamPos


def execute_cmd(cmd_string):
    #  system("clear")
    # retcode = system(cmd_string)
    stdout = subprocess.check_output(cmd_string, shell=True)
    # if retcode == 0:
    #     if Debug > 1: print("\nCommand executed successfully")
    # else:
    #     if Debug > 1: print("\nCommand terminated with error: " + str(retcode))
    # # raw_input("Press enter")
    return stdout


def keybuffer_set(event, value):
    key_name = Gdk.keyval_name(event.keyval)
    # print("key", key_name, value)
    if key_name == "Left" or key_name.replace("A", "a", 1) == "a":
        KEY_control.Left = value

    elif key_name == "Right" or key_name.replace("D", "d", 1) == "d":
        KEY_control.Right = value

    elif key_name == "Up" or key_name.replace("W", "w", 1) == "w":
        KEY_control.Up = value

    elif key_name == "Down" or key_name.replace("S", "s", 1) == "s":
        KEY_control.Down = value

    elif key_name == "space":
        COMM_vars.speed = 0
        COMM_vars.direction = 0
        KEY_control.Space = value

    if event.state is True and Gdk.KEY_Shift_L is not KEY_control.Shift:
        KEY_control.Shift = Gdk.KEY_Shift_L
        print("SHIIIIIIIIIIIIIIIFT!!!")

    return key_name


def mousebuffer_set(mouse_event, value):
    if mouse_event.button == Gdk.BUTTON_PRIMARY:
        KEY_control.MouseBtn[LEFT] = value
        if value is True:
            KEY_control.MouseXY = [int(mouse_event.x) / 2,
                                   int(mouse_event.y) / 2]

    if mouse_event.button == Gdk.BUTTON_SECONDARY:
        KEY_control.MouseBtn[RIGHT] = value
        KEY_control.MouseXY = [0, 0]


